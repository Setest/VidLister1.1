<?php/*данный способ добавляет плагины и их события динамически,да есть некоторые неудобства в том, что приходится создавать больше файловнужны папки desc, где содержится описание плагина и events, в котором перечисляются событиятого или иного плагина. Но все же, нет нужды каждый раз вносить изменения в кодеданного файла для того что бы что то добавить к примеру.*/// create a handler for the directory$dir=$sources['plugins'];$handler = opendir($dir);// open directory and walk through the filenames$i=0;while ($file = readdir($handler)) {// if file isn't this directory or its parent, add it to the results	if ($file != "." && $file != ".." && is_file($dir.$file)) {		$i++;				$file_name = pathinfo($dir.$file, PATHINFO_FILENAME);		$file_ext = pathinfo($dir.$file, PATHINFO_EXTENSION);				// получаем описание к файлу		$desc_file=$dir."desc/".$file_name.".txt";		if (is_file($desc_file)){$desc = file_get_contents($desc_file);}		else {$desc = $file_name;}				// создаем плагин		// $modx->log(modX::LOG_LEVEL_INFO,print_r($file,true));flush();		$modx->log(modX::LOG_LEVEL_INFO,"Description for plugin [{$file_name}]: $desc");flush();		$plugin[$i] = $modx->newObject('modPlugin');		$plugin[$i] -> fromArray(array(			'id' => $i,			'category' => 0,			'name' => $file_name,			'description' => $desc,			'plugincode' => getFilePackagesContent($dir.$file),		),'',true,true);		// прикрепляем к плагину его свойства		 /*$properties = include $sources['data'].'properties/properties.resizeimageonupload.php';		 вариант при получении параметров из экспортного файла*/		$properties = file_get_contents($dir.'properties/'.$file_name.'.json');		if (!empty($properties)){			// $modx->log(modX::LOG_LEVEL_INFO,print_r($properties,true));flush();			$plugin[$i]->setProperties(json_decode($properties,true)); // принимает только массив, вполне подходят экспортные параметры в UTF8-without BOM		}		unset($properties);				// добавляем к плагину его события		// мы делаем привязку к событиям но событие само на данный момент не создано		// правильно будет, если создать его после того как плагин будет добавлен		// НО если мы добавлем много плагинов как в нашем случае, нам будет не просто		// получить их записанные события и как вариант прописать заранее созданные события в системных событиях		// тут https://github.com/opengeek/dbapi/blob/master/_build/build.transport.php#L56		// можно подчерпнуть много информации на этот счет				// нет так не пойдет нужно создавать в резольверс, иначе я смогу создать его		// только при создании пакета :) а это не правильно				if (is_file($dir."events/".$file))		$events = include $dir."events/".$file;		if (is_array($events) && !empty($events)) {			// проходимся по всем событиям			foreach ($events as $eventName=>$eventProp) {				$events_obj[$eventName] = $modx->newObject('modPluginEvent');				$events_obj[$eventName]->fromArray(array('event' => $eventName,$eventProp),'',true,true);			}			// добавляем события в плагин			$plugin[$i]->addMany($events_obj);		    $modx->log(xPDO::LOG_LEVEL_ERROR,"Events for plugin [{$file_name}] exist!"); flush();		}		else {		    $modx->log(xPDO::LOG_LEVEL_ERROR,"Could not find events for plugin [{$file_name}]!"); flush();		}		unset($events);			}}// tidy up: close the handlerclosedir($handler);return $plugin;